"""
Manga API Endpoints
Handles manga library management
"""

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Query
from sqlalchemy.orm import Session
from sqlalchemy import or_
from typing import List, Optional
from app.database import get_db
from app.models.manga import Manga
from app.models.chapter import Chapter
from app.schemas.manga import MangaCreate, MangaResponse, MangaUpdate, MangaSearch
from app.services.scraper import TomosMangaScraper
import logging

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/manga", tags=["manga"])


@router.get("/", response_model=List[MangaResponse])
def list_manga(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    monitored: Optional[bool] = None,
    search: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    List all manga in library

    Args:
        skip: Number of records to skip
        limit: Maximum number of records to return
        monitored: Filter by monitored status
        search: Search in title
        db: Database session

    Returns:
        List of manga
    """
    query = db.query(Manga)

    if monitored is not None:
        query = query.filter(Manga.monitored == monitored)

    if search:
        search_pattern = f"%{search}%"
        query = query.filter(
            or_(
                Manga.title.ilike(search_pattern),
                Manga.slug.ilike(search_pattern)
            )
        )

    manga = query.offset(skip).limit(limit).all()
    return manga


@router.get("/search", response_model=List[MangaSearch])
def search_manga(
    query: str = Query(..., min_length=2),
):
    """
    Search for manga on tomosmanga.com

    Args:
        query: Search term (minimum 2 characters)

    Returns:
        List of search results
    """
    scraper = TomosMangaScraper()

    try:
        results = scraper.search_manga(query)
        return [
            MangaSearch(
                title=r['title'],
                url=r['url'],
                cover=r.get('cover'),
                slug=r.get('slug', '')
            )
            for r in results
        ]
    except Exception as e:
        logger.error(f"Search error: {e}")
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


@router.post("/", response_model=MangaResponse, status_code=201)
async def add_manga(
    manga: MangaCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Add new manga to library

    Args:
        manga: Manga creation data
        background_tasks: FastAPI background tasks
        db: Database session

    Returns:
        Created manga
    """
    # Check if manga already exists
    existing = db.query(Manga).filter(Manga.url == manga.url).first()
    if existing:
        raise HTTPException(status_code=400, detail="Manga already exists in library")

    scraper = TomosMangaScraper()

    try:
        # Get manga details
        details = scraper.get_manga_details(manga.url)

        if not details:
            raise HTTPException(status_code=400, detail="Could not fetch manga details from URL")

        # Create manga in database
        db_manga = Manga(
            title=details['title'],
            slug=manga.url.rstrip('/').split('/')[-1],
            url=manga.url,
            cover_url=details.get('cover'),
            description=details.get('description'),
            monitored=manga.monitored if hasattr(manga, 'monitored') else True
        )

        db.add(db_manga)
        db.commit()
        db.refresh(db_manga)

        # Add chapters to database
        if details.get('chapters'):
            for ch_data in details['chapters']:
                # Select best download link
                download_url = ""
                if ch_data.get('download_links'):
                    download_url = ch_data['download_links'][0]['url']

                chapter = Chapter(
                    manga_id=db_manga.id,
                    number=ch_data['number'],
                    title=ch_data.get('title', ''),
                    url=ch_data.get('url', manga.url),
                    download_url=download_url,
                    status='pending'
                )
                db.add(chapter)

            db.commit()
            logger.info(f"Added {len(details['chapters'])} chapters for {db_manga.title}")

        logger.info(f"Added manga: {db_manga.title}")
        return db_manga

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error adding manga: {e}")
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to add manga: {str(e)}")


@router.get("/{manga_id}", response_model=MangaResponse)
def get_manga(manga_id: int, db: Session = Depends(get_db)):
    """
    Get manga details

    Args:
        manga_id: Manga ID
        db: Database session

    Returns:
        Manga details
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    return manga


@router.put("/{manga_id}", response_model=MangaResponse)
def update_manga(
    manga_id: int,
    manga_update: MangaUpdate,
    db: Session = Depends(get_db)
):
    """
    Update manga settings

    Args:
        manga_id: Manga ID
        manga_update: Update data
        db: Database session

    Returns:
        Updated manga
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    # Update fields
    update_data = manga_update.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(manga, key, value)

    db.commit()
    db.refresh(manga)

    logger.info(f"Updated manga: {manga.title}")
    return manga


@router.delete("/{manga_id}", status_code=204)
def delete_manga(manga_id: int, db: Session = Depends(get_db)):
    """
    Delete manga and all its chapters

    Args:
        manga_id: Manga ID
        db: Database session
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    title = manga.title
    db.delete(manga)
    db.commit()

    logger.info(f"Deleted manga: {title}")
    return None


@router.post("/{manga_id}/refresh", status_code=202)
async def refresh_manga(
    manga_id: int,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    """
    Force refresh of manga chapters

    Args:
        manga_id: Manga ID
        background_tasks: FastAPI background tasks
        db: Database session

    Returns:
        Status message
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    # Add task to background
    background_tasks.add_task(_refresh_manga_task, manga_id)

    return {"status": "refresh_queued", "manga_id": manga_id}


async def _refresh_manga_task(manga_id: int):
    """
    Background task to refresh manga chapters

    Args:
        manga_id: Manga ID
    """
    from app.database import SessionLocal

    db = SessionLocal()
    try:
        manga = db.query(Manga).filter(Manga.id == manga_id).first()
        if not manga:
            return

        scraper = TomosMangaScraper()
        details = scraper.get_manga_details(manga.url)

        if not details or not details.get('chapters'):
            logger.warning(f"No chapters found for {manga.title}")
            return

        # Get existing chapter numbers
        existing = db.query(Chapter.number).filter(Chapter.manga_id == manga_id).all()
        existing_numbers = {ch.number for ch in existing}

        # Add new chapters
        new_count = 0
        for ch_data in details['chapters']:
            if ch_data['number'] not in existing_numbers:
                download_url = ""
                if ch_data.get('download_links'):
                    download_url = ch_data['download_links'][0]['url']

                chapter = Chapter(
                    manga_id=manga_id,
                    number=ch_data['number'],
                    title=ch_data.get('title', ''),
                    url=ch_data.get('url', manga.url),
                    download_url=download_url,
                    status='pending'
                )
                db.add(chapter)
                new_count += 1

        db.commit()
        logger.info(f"Refresh completed for {manga.title}: {new_count} new chapters")

    except Exception as e:
        logger.error(f"Error in refresh task: {e}")
        db.rollback()
    finally:
        db.close()


@router.get("/{manga_id}/chapters", response_model=List)
def get_manga_chapters(
    manga_id: int,
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Get chapters for a manga

    Args:
        manga_id: Manga ID
        status: Filter by status
        db: Database session

    Returns:
        List of chapters
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    query = db.query(Chapter).filter(Chapter.manga_id == manga_id)

    if status:
        query = query.filter(Chapter.status == status)

    chapters = query.order_by(Chapter.number).all()
    return chapters


@router.get("/{manga_id}/stats")
def get_manga_stats(manga_id: int, db: Session = Depends(get_db)):
    """
    Get statistics for a manga

    Args:
        manga_id: Manga ID
        db: Database session

    Returns:
        Manga statistics
    """
    manga = db.query(Manga).filter(Manga.id == manga_id).first()

    if not manga:
        raise HTTPException(status_code=404, detail="Manga not found")

    total_chapters = db.query(Chapter).filter(Chapter.manga_id == manga_id).count()
    downloaded = db.query(Chapter).filter(
        Chapter.manga_id == manga_id,
        Chapter.status.in_(['downloaded', 'converted', 'sent'])
    ).count()
    pending = db.query(Chapter).filter(
        Chapter.manga_id == manga_id,
        Chapter.status == 'pending'
    ).count()
    sent = db.query(Chapter).filter(
        Chapter.manga_id == manga_id,
        Chapter.status == 'sent'
    ).count()

    return {
        "manga_id": manga_id,
        "title": manga.title,
        "total_chapters": total_chapters,
        "downloaded": downloaded,
        "pending": pending,
        "sent": sent,
        "monitored": manga.monitored
    }
